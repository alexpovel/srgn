---
source: tests/cli.rs
expression: "CommandSnap\n{\n    args, stdin:\n    stdin.map(|s|\n    s.split_inclusive('\\n').map(ToOwned::to_owned).collect_vec()), stdout:\n    stdout.split_inclusive('\\n').map(ToOwned::to_owned).collect_vec(),\n    exit_code,\n}"
info:
  stderr: []
---
args:
  - "--python"
  - strings
  - "--glob"
  - "**/*.py"
  - is
stdin:
  - "\"\"\"\n"
  - "Module for testing various Python grammar elements.\n"
  - "\"\"\"\n"
  - "\n"
  - "import asyncio\n"
  - "import os as operating_system\n"
  - "from collections import namedtuple\n"
  - "from math import *\n"
  - "from math import acos as soca\n"
  - "from typing import Dict, List\n"
  - "\n"
  - "from ..parent import x\n"
  - "from .sibling import y\n"
  - "\n"
  - "# Global variable\n"
  - "test_var: int = 10\n"
  - "\n"
  - "\n"
  - "# Free function\n"
  - "def free_func():\n"
  - "    \"\"\"A free function for testing.\"\"\"\n"
  - "    global test_var\n"
  - "    test_var += 1\n"
  - "    print(f\"Global test_var is now {test_var}\")\n"
  - "\n"
  - "\n"
  - "# Decorator for functions\n"
  - "def func_decorator(func):\n"
  - "    \"\"\"Decorator for free function.\"\"\"\n"
  - "\n"
  - "    def wrapper(*args, **kwargs):\n"
  - "        print(\"Function decorator called\")\n"
  - "        return func(*args, **kwargs)\n"
  - "\n"
  - "    return wrapper\n"
  - "\n"
  - "\n"
  - "@func_decorator\n"
  - "def decorated_func():\n"
  - "    \"\"\"Function with a decorator.\"\"\"\n"
  - "    print(\"Inside decorated function\")\n"
  - "\n"
  - "\n"
  - "# Class definition\n"
  - "class TestClass:\n"
  - "    \"\"\"Class for testing various features.\"\"\"\n"
  - "\n"
  - "    class_var = \"Class variable\"\n"
  - "\n"
  - "    # Decorator for methods\n"
  - "    @staticmethod\n"
  - "    def static_decorator(func):\n"
  - "        \"\"\"Decorator for static methods.\"\"\"\n"
  - "\n"
  - "        def wrapper(*args, **kwargs):\n"
  - "            print(\"Static method decorator called\")\n"
  - "            return func(*args, **kwargs)\n"
  - "\n"
  - "        return wrapper\n"
  - "\n"
  - "    # Class method\n"
  - "    @classmethod\n"
  - "    def class_method(cls) -> None:\n"
  - "        \"\"\"Class method.\"\"\"\n"
  - "        cls.class_var += \" updated\"\n"
  - "        print(f\"Class variable is now {cls.class_var}\")\n"
  - "\n"
  - "    # Method\n"
  - "    def instance_method(self) -> None:\n"
  - "        \"\"\"Instance method.\"\"\"\n"
  - "        self.instance_var = \"Instance variable\"\n"
  - "        print(f\"Instance variable is {self.instance_var}\")\n"
  - "\n"
  - "    @staticmethod\n"
  - "    @static_decorator\n"
  - "    def static_method() -> None:\n"
  - "        \"\"\"Static method.\"\"\"\n"
  - "        print(\"Inside static method\")\n"
  - "\n"
  - "\n"
  - "# Lambda expression\n"
  - "square = lambda x: x * x\n"
  - "\n"
  - "# Multiline string\n"
  - "multi_line_str = \"\"\"\n"
  - "This is a\n"
  - "multi-line string\n"
  - "for testing purposes.\n"
  - "\"\"\"\n"
  - "\n"
  - "multiline_f_string = f\"\"\"This is a\n"
  - "multiline{f_string} string\n"
  - "spanning several lines\n"
  - "\"\"\"\n"
  - "\n"
  - "raw_string = r\"This is a raw string with no special treatment for \\n\"\n"
  - "bytes_string = b\"This is a bytes string\"\n"
  - "bytes_string = rf\"This is a raw f-string with {raw_string}\"\n"
  - "\n"
  - "\n"
  - "# List comprehension\n"
  - "squared_numbers = [\"x\" + square(x) for x in range(10)]\n"
  - "\n"
  - "# Set comprehension\n"
  - "unique_squares = {square(x) for x in range(10)}\n"
  - "\n"
  - "# Dictionary comprehension\n"
  - "squares_dict = {x: square(x) for x in range(10)}\n"
  - "\n"
  - "\n"
  - "# Exception handling\n"
  - "def exception_handling(x) -> None:\n"
  - "    \"\"\"Function for testing exceptions.\"\"\"\n"
  - "    try:\n"
  - "        if x < 0:\n"
  - "            raise ValueError(\"Negative value\")\n"
  - "        elif x == 0:\n"
  - "            raise ZeroDivisionError(\"Division by zero\")\n"
  - "        result = 10 / x\n"
  - "    except ZeroDivisionError as e:\n"
  - "        print(f\"Caught an exception: {e}\")\n"
  - "    except ValueError as e:\n"
  - "        print(f\"Caught an exception: {e}\")\n"
  - "    else:\n"
  - "        print(\"No exceptions caught\")\n"
  - "    finally:\n"
  - "        print(\"This will always be printed\")\n"
  - "\n"
  - "\n"
  - "# Statements\n"
  - "def modify_nonlocal():\n"
  - "    \"\"\"Function demonstrating nonlocal statement.\"\"\"\n"
  - "    nonlocal_var = \"Initial value\"\n"
  - "\n"
  - "    def inner():\n"
  - "        nonlocal nonlocal_var\n"
  - "        nonlocal_var = \"Modified value\"\n"
  - "\n"
  - "    inner()\n"
  - "    print(f\"Nonlocal variable is {nonlocal_var}\")\n"
  - "\n"
  - "\n"
  - "def inplace_operations():\n"
  - "    \"\"\"Function demonstrating inplace operators.\"\"\"\n"
  - "    x = 10\n"
  - "    x += 5\n"
  - "    x -= 3\n"
  - "    x *= 2\n"
  - "    x /= 4\n"
  - "    print(f\"Inplace operations result: {x}\")\n"
  - "\n"
  - "\n"
  - "# Control flow\n"
  - "def control_flow():\n"
  - "    \"\"\"Function demonstrating various control flow statements.\"\"\"\n"
  - "    # if statement\n"
  - "    if test_var > 5:\n"
  - "        print(\"test_var is greater than 5\")\n"
  - "    else:\n"
  - "        print(\"test_var is 5 or less\")\n"
  - "\n"
  - "    # while statement\n"
  - "    counter = 0\n"
  - "    while counter < 3:\n"
  - "        print(f\"Counter is {counter}\")\n"
  - "        counter += 1\n"
  - "\n"
  - "    # for statement\n"
  - "    for i in range(3):\n"
  - "        print(f\"Loop iteration {i}\")\n"
  - "\n"
  - "    # with statement\n"
  - "    with open(__file__) as f:\n"
  - "        content = f.readline()\n"
  - "        print(\"Read from file:\", content)\n"
  - "\n"
  - "\n"
  - "# Pattern matching\n"
  - "def match_statement(x):\n"
  - "    \"\"\"Function demonstrating match statement.\"\"\"\n"
  - "    match x:\n"
  - "        case 0:\n"
  - "            print(\"Zero\")\n"
  - "        case 1:\n"
  - "            print(\"One\")\n"
  - "        case _:\n"
  - "            print(\"Other\")\n"
  - "\n"
  - "\n"
  - "# Async syntax\n"
  - "async def async_function():\n"
  - "    \"\"\"Function demonstrating async syntax.\"\"\"\n"
  - "    await asyncio.sleep(1)\n"
  - "    print(\"Async function executed\")\n"
  - "\n"
  - "\n"
  - "# Main execution\n"
  - "if __name__ == \"__main__\":\n"
  - "    free_func()\n"
  - "    decorated_func()\n"
  - "    TestClass.class_method()\n"
  - "    instance = TestClass()\n"
  - "    instance.instance_method()\n"
  - "    TestClass.static_method()\n"
  - "    print(square(5))\n"
  - "    exception_handling(0)\n"
  - "    modify_nonlocal()\n"
  - "    inplace_operations()\n"
  - "    control_flow()\n"
  - "    match_statement(1)\n"
  - "    asyncio.run(async_function())\n"
stdout:
  - "24:28-30:    print(f\"Global test_var is now {test_var}\")\n"
  - "66:31-33:        print(f\"Class variable is now {cls.class_var}\")\n"
  - "72:34-36:        print(f\"Instance variable is {self.instance_var}\")\n"
  - "86:2-4;5-7:This is a\n"
  - "91:27-29;30-32:multiline_f_string = f\"\"\"This is a\n"
  - "96:17-19;20-22:raw_string = r\"This is a raw string with no special treatment for \\n\"\n"
  - "97:19-21;22-24:bytes_string = b\"This is a bytes string\"\n"
  - "98:20-22;23-25:bytes_string = rf\"This is a raw f-string with {raw_string}\"\n"
  - "118:40-42:            raise ZeroDivisionError(\"Division by zero\")\n"
  - "127:17-19:        print(\"This will always be printed\")\n"
  - "140:30-32:    print(f\"Nonlocal variable is {nonlocal_var}\")\n"
  - "158:24-26:        print(\"test_var is greater than 5\")\n"
  - "160:24-26:        print(\"test_var is 5 or less\")\n"
  - "165:24-26:        print(f\"Counter is {counter}\")\n"
exit_code: 0
